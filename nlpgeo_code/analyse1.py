import numpy as np
import matplotlib.pyplot as plt
import os.path
import colorcet as cc
from geopy.distance import geodesic
from utils.gMapsQuery import initGeo, getLocationfromName, getCoordsfromName
import random
import pycountry_convert as pc
import matplotlib.ticker as mtick

from utils.giniCoeff import diversity
from utils.carboncost import distance_to_emissions

random.seed(0)
dataPath = './'
cachePath = './'
initGeo(cachePath)

papers = np.loadtxt(dataPath + 'papers-ref.tsv', delimiter='\t', comments=None, dtype=str)
volumes = np.loadtxt(dataPath + 'volumes-ref.tsv', delimiter='\t', comments=None, dtype=str)

print("Have " + str(papers.shape[0]) + " publications.")

print("=============== AFFILIATIONS ===============")

domains = papers[:, 3]
domainsU, pos = np.unique(domains, return_inverse=True)
counts = np.bincount(pos)

print("Coming from " + str(len(domainsU) - 1) + " domains.")

print("Percent unknown (ignored): " + str(counts[0] / papers.shape[0]))

domainsU = domainsU[1:]
counts = counts[1:]
g = diversity(counts)

print("Diversity of output: " + str(g))

order = np.argsort(counts)[::-1]
counts = counts[order]
domainsU = domainsU[order]
summed = np.argmax(np.cumsum(counts) / sum(counts) >= 0.5) + 1

print("Half of the output generated by " + str(summed) + " affiliations, i.e. " + str(summed / len(domainsU)))

print("=============== COUNTRIES ===============")


def getCountry(location):
    if location in ['@', '?']:
        return location
    geoInfo = getLocationfromName(location)
    country = '?'
    if len(geoInfo) > 0:
        for component in geoInfo[0]['address_components']:
            if 'country' in component['types']:
                if component['long_name'] != '':
                    country = component['long_name']
    if country in ['Macao', 'Hong Kong']:
        country = 'China'
    return (country)


countries = [getCountry(location) for location in papers[:, 4]]

countriesU, pos = np.unique(countries, return_inverse=True)
counts = np.bincount(pos)

print("Coming from " + str(len(countriesU) - 1) + " countries.")

print("Percent unknown (ignored): " + str(counts[0] / papers.shape[0]))

countriesU = countriesU[1:]
counts = counts[1:]
g = diversity(counts)

print("Diversity of output: " + str(g))

order = np.argsort(counts)[::-1]
counts = counts[order]
countriesU = countriesU[order]
summed = np.argmax(np.cumsum(counts) / sum(counts) >= 0.5) + 1

print("Half of the output generated by " + str(summed) + " countries, i.e. " + str(summed / len(countriesU)))

print("These are: " + str(countriesU[:summed]))
print("All: " + str(countriesU))

eventYears = {volumes[i, 0]: volumes[i, 2] for i in range(volumes.shape[0])}
years = []
for volumeId in papers[:, 0]:
    year = eventYears[volumeId]
    if year.isnumeric():
        years.append(int(year))
    else:
        years.append(0)

yearMin = 1975
yearMax = 2020

if os.path.isfile(cachePath + 'countries.npy'):
    mat = np.load(cachePath + 'countries.npy')
else:
    mat = np.zeros(shape=(yearMax - yearMin + 1, len(countriesU)))
    for i in range(mat.shape[0]):
        for j in range(mat.shape[1]):
            mat[i][j] = np.sum(np.logical_and(np.char.equal(countries, countriesU[j]), np.equal(years, yearMin + i)))
        if np.sum(mat[i, :]) > 0:
            mat[i, :] = mat[i, :] / np.sum(mat[i, :])
    np.save(cachePath + 'countries.npy', mat)

plt.rcParams.update({'font.size': 12})
plt.figure(figsize=(6, 4))
fig, a = plt.subplots()
prev = np.zeros((mat.shape[0],))
for j in range(mat.shape[1]):
    a.bar(range(yearMin, yearMax + 1), mat[:, j], bottom=prev, label=countriesU[j], color=cc.glasbey_hv[j], width=1.0)
    prev = prev + mat[:, j]

plt.ylim(0, 1.0)
plt.xlim(yearMin - 0.5, yearMax + 0.5)
a.yaxis.set_visible(True)
a.yaxis.set_major_formatter(mtick.PercentFormatter(1.0))
giniYears = [diversity(mat[i, :]) for i in range(mat.shape[0])]
axes2 = plt.twinx()
axes2.plot(range(yearMin, yearMax + 1), giniYears, lw=2.0, color='white')
axes2.set_ylim(0.0, 0.15)
plt.savefig(dataPath + 'countriesYears.pdf', bbox_inches='tight', pad_inches=0.02)

print("=============== EVENTS ===============")
print("Total number of events (volumes): " + str(volumes.shape[0]))

eventCountries = {volume[0]: getCountry(volume[3]) for volume in volumes}

print("Happening in countries: " + str(len(set(eventCountries.values())) - 2))

countriesUold = countriesU

countries = [eventCountries[paper[0]] for paper in papers]
countriesU, pos = np.unique(countries, return_inverse=True)
counts = np.bincount(pos)

g = diversity(counts[1:])

print("Unequality of output (for countries): " + str(g))

countriesU2 = []
counts2 = []
for country in countriesUold:
    if country in countriesU:
        countriesU2.append(country)
        counts2.append(counts[list(countriesU).index(country)])

countriesU2.append('@')
counts2.append(counts[list(countriesU).index('@')])
countriesU = countriesU2
counts = counts2

if os.path.isfile(cachePath + 'events.npy'):
    mat = np.load(cachePath + 'events.npy')
else:
    mat = np.zeros(shape=(yearMax - yearMin + 1, len(countriesU)))
    for i in range(mat.shape[0]):
        year = yearMin + i
        # print("Computing for year: " + str(year))
        for j in range(mat.shape[1]):
            country = countriesU[j]
            # print("Computing for country: " + str(country))
            val = np.sum(np.logical_and(np.char.equal(countries, countriesU[j]), np.equal(years, yearMin + i)))
            # print("Found: " + str(val))
            mat[i][j] = val
        if np.sum(mat[i, :]) > 0:
            mat[i, :] = mat[i, :] / np.sum(mat[i, :])
    np.save(cachePath + 'events.npy', mat)

print("Work presented online in 2020: " + str(mat[-1, -1]))

plt.rcParams.update({'font.size': 12})
plt.figure(figsize=(6, 4))
fig, a = plt.subplots()
prev = np.zeros((mat.shape[0],))
for j in range(mat.shape[1]):
    color = cc.glasbey_hv[j]
    if j == mat.shape[1] - 1:
        color = 'lightgray'
    a.bar(range(yearMin, yearMax + 1), mat[:, j], bottom=prev, label=countriesU[j], color=color, width=1.0)
    prev = prev + mat[:, j]

plt.ylim(0, 1.0)
plt.xlim(yearMin - 0.5, yearMax + 0.5)
a.yaxis.set_visible(True)
a.yaxis.set_major_formatter(mtick.PercentFormatter(1.0))
giniYears = [diversity(mat[i, :-1]) for i in range(mat.shape[0])]
axes2 = plt.twinx()
axes2.plot(range(yearMin, yearMax + 1), giniYears, lw=2.0, color='white')
axes2.set_ylim(0.0, 0.15)
plt.savefig(dataPath + 'events.pdf', bbox_inches='tight', pad_inches=0.02)

print("=============== DISTANCES ===============")

eventLocations = {volume[0]: volume[3] for volume in volumes}

coordsFrom = [getCoordsfromName(location) for location in papers[:, 4]]
coordsTo = [getCoordsfromName(eventLocations[eventId]) for eventId in papers[:, 0]]

valid = np.array([coordsFrom[i] != (0, 0) and coordsTo[i] != (0, 0) for i in range(len(coordsFrom))])
travels_pre = np.array([geodesic(coordsFrom[i], coordsTo[i]).km for i in range(len(coordsFrom))])
travels = np.array([travels_pre[i] for i in range(len(coordsFrom)) if valid[i]])

print("Recorded " + str(len(travels)) + " travels with average length " + str(sum(travels) / len(travels)) + " km.")

maximum = np.amax(travels)
print("Maximum: " + str(maximum))
print("Other long travels: ")
for i in range(papers.shape[0]):
    if valid[i]:
        if travels_pre[i] > 19000:
            print(travels_pre[i])
            print(papers[i, 1])
            print(papers[i, 4])
            print(eventLocations[papers[i, 0]])

plt.figure(figsize=(6, 4))
plt.hist(travels, bins=30)
plt.locator_params(axis='x', nbins=6)
plt.savefig(dataPath + 'travels.pdf', bbox_inches='tight')

print("=============== GAINS ===============")

print("Generating random travels")
validS=[]
travels_preS=[]
travelsS=[]
for i in range(10):
    coordsToS = coordsTo.copy()
    random.shuffle(coordsToS)
    validShere=[coordsFrom[i] != (0, 0) and coordsToS[i] != (0, 0) for i in range(len(coordsFrom))]
    validS.extend(validShere)
    travels_preShere= [geodesic(coordsFrom[i], coordsToS[i]).km for i in range(len(coordsFrom))]
    travels_preS.extend(travels_preShere)
    travelsShere= np.array([travels_preShere[i] for i in range(len(coordsFrom)) if validShere[i]])
    travelsS.extend(travelsShere)

print("After shuffling " + str(len(travelsS)) + " travels with average length " + str(
    sum(travelsS) / len(travelsS)) + " km.")

bins = np.linspace(0, 20000, 30)
plt.figure(figsize=(6, 4))
plt.hist([travels, travelsS[:len(travels)]], bins, density=False, label=['travels observed', 'travels expected'])
plt.legend(loc='upper right')
plt.locator_params(axis='x', nbins=6)
plt.savefig(dataPath + 'travelsS.pdf', bbox_inches='tight')

costsReal=[distance_to_emissions(x,2020)[0] for x in travels]
costsSim=[distance_to_emissions(x,2020)[0] for x in travelsS[:len(travels)]]
print("Saved "+str(sum(costsSim)-sum(costsReal))+" kg of CO2, that is "+str((sum(costsSim)-sum(costsReal))*100/sum(costsSim))+" %")

sizes = []
distances = []
divers = []
types = []
volNames = []
for volume in volumes:
    volumeId = volume[0]
    papersHere = papers[papers[:, 0] == volumeId,]
    travelsHere = travels_pre[np.logical_and(papers[:, 0] == volumeId, valid)]
    if (len(travelsHere) < 10):
        continue
    countriesHere = [getCountry(location) for location in papersHere[:, 4]]
    countriesU, pos = np.unique(countriesHere, return_inverse=True)
    counts = np.bincount(pos)
    if '?' in countriesU:
        i = np.where(countriesU == '?')[0][0]
        counts = np.delete(counts, i)
    g = diversity(np.concatenate([counts, np.array([0] * (135 - len(counts)))]))
    sizes.append(papersHere.shape[0])
    distances.append(np.mean(travelsHere))
    divers.append(g)
    volNames.append(volumeId)
    if 'workshop' in volume[1].lower() or volumeId.startswith('W'):
        types.append('Workshop')
    elif 'Annual Meeting of the Association for Computational Linguistics' in volume[1] or 'Annual Meeting of the ACL' in volume[1] :
        types.append('ACL')
    elif 'International Conference on Computational Linguistics' in volume[1]:
        types.append('COLING')
    elif 'Conference on Language Resources and Evaluation' in volume[1]:
        types.append('LREC')
    elif 'Empirical Methods in Natural Language Processing' in volume[1]:
        types.append('EMNLP')
    elif 'North American Chapter of the Association for Computational Linguistics' in volume[1]:
        types.append('NAACL')
    elif 'European Chapter of the Association for Computational Linguistics' in volume[1]:
        types.append('EACL')
    elif 'Recent Advances in Natural Language Processing' in volume[1]:
        types.append('RANLP')
    elif 'International Joint Conference on Natural Language Processing' in volume[1]:
        types.append('IJCNLP')
    else:
        types.append('Other')
    print(volumeId + '\t' + str(papersHere.shape[0]) + '\t' + str(np.mean(travelsHere)) + '\t' + str(len(counts)))

onlineVolumes = [volume for volume in eventCountries if
                 (eventCountries[volume] == '@' and (
                             volume in ['2020.tacl.1', '2020.findings.emnlp'] or not (volume.startswith('2020'))))]
countriesOnline = [getCountry(paper[4]) for paper in papers if paper[0] in onlineVolumes]
countriesOnline = [country for country in countriesOnline if country != '?']
countriesU, pos = np.unique(countriesOnline, return_inverse=True)
counts = np.bincount(pos)
gOnline = diversity(np.concatenate([counts, np.array([0] * (135 - len(counts)))]))

colorDict = {'Other': cc.glasbey_hv[4], 'Workshop': 'black', 'ACL': cc.glasbey_hv[1], 'COLING': cc.glasbey_hv[2],
             'LREC': cc.glasbey_hv[3], 'EMNLP': cc.glasbey_hv[5], 'NAACL': cc.glasbey_hv[6],
             'EACL': 'brown', 'RANLP': cc.glasbey_hv[8], 'IJCNLP': cc.glasbey_hv[9]}
colors = [colorDict[type] for type in types]

fig, ax = plt.subplots(figsize=(12, 5))
for type1 in colorDict.keys():
    plt.scatter([distances[i] for i in range(len(types)) if types[i] == type1],
                [divers[i] for i in range(len(types)) if types[i] == type1],
                s=[sizes[i] for i in range(len(types)) if types[i] == type1], c=colorDict[type1], label=type1)

plt.plot([0, 12000], [gOnline, gOnline], '--', color='black')

lgd = ax.legend(numpoints=1, loc=1, title="Event type",ncol=2)
for handle in lgd.legendHandles:
    handle.set_sizes([100.0])

# plt.legend(loc='upper right',numpoints=1)
plt.xlabel("Mean travel distance")
plt.ylabel("Diversity")
plt.savefig(dataPath + 'confs.pdf', bbox_inches='tight')

countries=[getCountry(location) for location in papers[:, 4]]
countriesS=countries*10

countryP=[]
travelMMeanP=[]
travelRMeanP=[]
sizeP=[]
for country in countriesUold:
    travelsMade=np.array([travels_pre[i] for i in range(len(travels_pre)) if valid[i] and countries[i]==country])
    if len(travelsMade)<15:
        continue
    travelsRandom = np.array([travels_preS[i] for i in range(len(travels_preS)) if validS[i] and countriesS[i]==country])
    sizeP.append(len(travelsMade))
    countryP.append(country)
    travelMMeanP.append((np.mean(travelsRandom)-np.mean(travelsMade)))
    travelRMeanP.append(np.mean(travelsRandom))
    print(country)
    print(np.mean(travelsMade)/np.mean(travelsRandom))

countryP[np.where(np.array(countryP)=='Myanmar (Burma)')[0][0]]='Myanmar'
continents=[pc.country_alpha2_to_continent_code(pc.country_name_to_country_alpha2(country, cn_name_format="default")) for country in countryP]
colorDict = {'NA': cc.glasbey_hv[1], 'AS': cc.glasbey_hv[2],'EU': cc.glasbey_hv[3], 'OC': cc.glasbey_hv[4], 'SA': cc.glasbey_hv[5],'AF': cc.glasbey_hv[6]}
nameDict = {'NA': 'North America', 'AS': 'Asia','EU': 'Europe', 'OC': 'Australia and Oceania', 'SA': 'South America','AF': 'Africa'}

fig, ax = plt.subplots(figsize=(12, 5))

for continent in colorDict.keys():
    plt.scatter([travelRMeanP[i] for i in range(len(countryP)) if continents[i]==continent], [travelMMeanP[i] for i in range(len(countryP)) if continents[i]==continent],c=[colorDict[continent]],label=continent,s=100)

for i in range(len(countryP)):
        plt.text(x=travelRMeanP[i], y=travelMMeanP[i], s=countryP[i], size=10)

ax.legend()
plt.ylabel("Travel distance reduction (km.)")
plt.xlabel("Expected travel distance (km.)")
#plt.xlim(4000, 15000)
#plt.ylim(0, 15000)
plt.plot([4500, 14000], [0, 0], '--', color='black')

plt.savefig(dataPath + 'locality.pdf', bbox_inches='tight')
